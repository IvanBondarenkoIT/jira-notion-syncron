# ADR-001: Выбор Clean Architecture

## Статус
✅ Принято (2024-10-21)

## Контекст

Проект требует:
- Поддержки множества внешних интеграций (Jira, Notion, файлы)
- Легкого тестирования бизнес-логики
- Возможности замены внешних зависимостей
- Масштабируемости для будущих расширений
- Понятной структуры для команды

## Решение

Выбрана **Clean Architecture** (Чистая архитектура) от Robert C. Martin со следующими слоями:

### 1. Domain Layer (Домен)
- Бизнес-модели (User, Task, Sprint, Department)
- Интерфейсы репозиториев
- Domain-сервисы
- **Не зависит** ни от чего

### 2. Application Layer (Приложение)
- Use Cases (варианты использования)
- DTOs (Data Transfer Objects)
- Зависит только от Domain

### 3. Infrastructure Layer (Инфраструктура)
- Реализации репозиториев
- Внешние интеграции (Jira, Notion)
- Парсеры файлов
- База данных
- Зависит от Domain и Application

### 4. Presentation Layer (Представление)
- CLI интерфейс
- API (в будущем)
- Зависит от Application

## Альтернативы

### 1. Монолитная структура
**Плюсы:**
- Проще для начала
- Меньше файлов

**Минусы:**
- Сложно тестировать
- Tight coupling
- Тяжело масштабировать

### 2. MVC Pattern
**Плюсы:**
- Привычная структура
- Хорошо для веб-приложений

**Минусы:**
- Не подходит для CLI приложения
- Нет четкого разделения бизнес-логики

### 3. Hexagonal Architecture
**Плюсы:**
- Похожа на Clean Architecture
- Хорошее разделение

**Минусы:**
- Более сложная для понимания
- Избыточна для текущих требований

## Последствия

### Положительные ✅

1. **Тестируемость**
   - Domain модели легко тестировать без внешних зависимостей
   - Можно мокировать интеграции

2. **Независимость от фреймворков**
   - Можно заменить Jira на другую систему
   - Можно добавить web-интерфейс позже

3. **Независимость бизнес-логики**
   - Domain не знает о внешних системах
   - Изменения в API не влияют на бизнес-правила

4. **Масштабируемость**
   - Легко добавлять новые интеграции
   - Легко добавлять новые use cases

5. **Понятная структура**
   - Четкое разделение ответственности
   - Легко найти нужный код

### Отрицательные ⚠️

1. **Больше файлов**
   - Больше boilerplate кода
   - Больше интерфейсов

2. **Начальная сложность**
   - Нужно время на понимание архитектуры
   - Больше планирования перед разработкой

3. **Over-engineering для простых задач**
   - Для простых CRUD может быть избыточно
   - Требует дисциплины в поддержании структуры

## Реализация

### Структура директорий
```
src/
├── domain/           # Бизнес-логика
│   ├── models/
│   ├── repositories/
│   └── services/
├── application/      # Use cases
│   ├── use_cases/
│   └── dto/
├── infrastructure/   # Внешний мир
│   ├── jira/
│   ├── notion/
│   └── parsers/
└── presentation/     # Интерфейсы
    └── cli/
```

### Dependency Rule
Зависимости направлены внутрь:
```
Presentation → Application → Domain
Infrastructure → Application → Domain
```

Domain не знает ни о чем.

## Примечания

- Используем Dependency Injection для инверсии зависимостей
- Repository Pattern для абстракции от источников данных
- Use Case Pattern для бизнес-операций

## Ссылки

- [The Clean Architecture (Uncle Bob)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Clean Architecture in Python](https://www.cosmicpython.com/)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)

## Авторы

- Senior Developer Team
- Дата: 2024-10-21

